plugins {
    id 'antlr'
}

// Apply core plugins.
apply plugin: 'java-library'

generateGrammarSource {
    arguments += '-visitor'
}

compileKotlin.dependsOn(generateGrammarSource)

idea.project.settings {
    taskTriggers {
        afterSync tasks.getByName('generateGrammarSource')
    }
}

dependencies {
    antlr "org.antlr:antlr4:$antlrVersion"

    api "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"

    implementation "commons-codec:commons-codec:$commonsCodecVersion"

    testImplementation "com.fasterxml.jackson.module:jackson-module-kotlin:$jacksonVersion"
}

def getLicenseHeader(int fromYear = 2017, int toYear = java.time.Year.now().value) {
    """\
        /*
         * Copyright (C) $fromYear-$toYear HERE Europe B.V.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         * License-Filename: LICENSE
         */

     """.stripIndent()
}

def licenseToEnumEntry(String license) {
    def enumName = license.toUpperCase().replaceAll('[-\\.]', '_').replace('+', 'PLUS')
    if (enumName[0].isNumber()) {
        enumName = "_$enumName"
    }
    return "$enumName(\"$license\")"
}

def generateEnumClass(String taskName, String description, String jsonUrl, String className, String resourcePath,
        Closure collectIds) {
    println "Fetching $description list..."

    def jsonSlurper = new groovy.json.JsonSlurper()
    def json = jsonSlurper.parse(jsonUrl.toURL())
    def ids = collectIds(json)

    println "Found ${ids.size()} SPDX $description identifiers."

    def enumFile = file("src/main/kotlin/${className}.kt")
    enumFile.write(getLicenseHeader())
    enumFile.append("""\
            package com.here.ort.spdx

            /**
             * An enum containing all SPDX $description IDs. This class is generated by the Gradle task
             * '$taskName'.
             */
            enum class $className(val id: String) {
            """.stripIndent())

    def enumValues = ids.collect { "    ${licenseToEnumEntry(it.toString())}" }.sort().join(',\n') + ';'
    enumFile.append(enumValues)
    enumFile.append("""

                companion object {
                    /**
                     * Return the enum value for the given [id], or null if it is no SPDX $description id.
                     */
                    fun forId(id: String) = ${className}.values().find { it.id == id }
                }

                /**
                 * The full $description text as a string.
                 */
                val text by lazy { javaClass.getResource("/$resourcePath/\$id").readText() }
            }
            """.stripIndent())

    println "Generated SPDX $description enum file '$enumFile'."

    return ids
}

def downloadLicenseTexts(String description, List<String> ids, String resourcePath) {
    println "Downloading SPDX $description texts..."
    def count = 0

    ids.each { id ->
        def resourceFile = file("src/main/resources/$resourcePath/$id")

        // Prefer the texts from ScanCode as these have better formatting than those from SPDX.
        def urls = [
                "https://raw.githubusercontent.com/nexB/scancode-toolkit/develop/src/licensedcode/data/licenses/${id.toLowerCase()}.LICENSE",
                "https://raw.githubusercontent.com/spdx/license-list-data/master/text/${id}.txt",
                "https://raw.githubusercontent.com/spdx/license-list-data/master/text/deprecated_${id}.txt"
        ]

        def i = urls.iterator()
        while (true) {
            if (i.hasNext()) {
                def url = i.next()

                try {
                    def text = url.toURL().text
                    if (!text.endsWith('\n')) text += '\n'
                    resourceFile.write(text)
                } catch (FileNotFoundException e) {
                    continue
                }

                println "Downloaded $description text ${++count} of ${ids.size()} for id '$id' from $url."
                break
            } else {
                throw new GradleException("Failed to download $description text for id '$id' from any of $urls.")
            }
        }
    }
}

task generateSpdxLicenseList {
    doLast {
        def description = 'license'
        def resourcePath = 'licenses'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json',
                'SpdxLicense',
                resourcePath,
                { json -> json.licenses.collect { it['licenseId'] } }
        )
        downloadLicenseTexts(description, ids, resourcePath)
    }
}

task generateSpdxLicenseExceptionList {
    doLast {
        def description = 'license exception'
        def resourcePath = 'exceptions'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/exceptions.json',
                'SpdxLicenseException',
                resourcePath,
                { json -> json.exceptions.collect { it['licenseExceptionId'] } }
        )
        downloadLicenseTexts(description, ids, resourcePath)
    }
}

task generateSpdxEnums(dependsOn: [generateSpdxLicenseList, generateSpdxLicenseExceptionList])
